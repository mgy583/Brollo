# 核心算法设计

## 1. 滑动窗口预算预测算法

### 1.1 算法概述

**目标**: 基于历史支出数据，预测当前预算周期的最终支出，实现分钟级预算偏差预警。

**核心思想**: 
- 使用滑动窗口捕捉最近N天的消费趋势
- 结合加权移动平均平滑短期波动
- 引入节假日因子修正特殊时期消费

### 1.2 算法原理

#### 1.2.1 数学模型

给定预算周期 [T_start, T_end]，当前时间点 T_now：

**1. 滑动窗口计算**

```
窗口大小: W = min(30, T_now - T_start)
每日平均支出: daily_avg = Σ(spending_i) / W  (i ∈ [T_now-W, T_now])
```

**2. 加权移动平均 (WMA)**

```
权重向量: w = [w_1, w_2, ..., w_W]
其中: w_i = i / (W * (W+1) / 2)  (近期权重更高)

WMA = Σ(spending_i * w_i)  (i = 1 to W)
```

**3. 节假日因子**

```
holiday_factor = {
  工作日: 1.0,
  周末: 1.3,
  法定节假日: 1.8,
  促销日(双11等): 2.5
}
```

**4. 预测公式**

```
剩余天数: days_left = T_end - T_now
已支出: spent_so_far
预测总支出: predicted_total = spent_so_far + WMA * days_left * avg_holiday_factor
预测超支: predicted_exceed = max(0, predicted_total - budget_amount)
```

**5. 置信度计算**

```
数据点数量: n = W
支出标准差: σ = sqrt(Σ(spending_i - daily_avg)² / n)
变异系数: CV = σ / daily_avg
置信度: confidence = 1 / (1 + CV)  (CV越小，置信度越高)
```

### 1.3 算法实现

```rust
use chrono::{DateTime, Utc, Datelike};
use std::collections::HashMap;

/// 滑动窗口预算预测器
pub struct BudgetPredictor {
    window_size: usize,
    holiday_factors: HashMap<String, f64>,
}

/// 预测结果
#[derive(Debug)]
pub struct PredictionResult {
    pub predicted_total: f64,
    pub predicted_exceed: f64,
    pub confidence: f64,
    pub daily_average: f64,
    pub weighted_average: f64,
}

impl BudgetPredictor {
    /// 创建新的预测器
    pub fn new(window_size: usize) -> Self {
        let mut holiday_factors = HashMap::new();
        holiday_factors.insert("workday".to_string(), 1.0);
        holiday_factors.insert("weekend".to_string(), 1.3);
        holiday_factors.insert("holiday".to_string(), 1.8);
        holiday_factors.insert("promotion".to_string(), 2.5);
        
        Self {
            window_size,
            holiday_factors,
        }
    }
    
    /// 执行预算预测
    pub fn predict(
        &self,
        spending_history: &[(DateTime<Utc>, f64)],  // (日期, 支出金额)
        budget_amount: f64,
        period_start: DateTime<Utc>,
        period_end: DateTime<Utc>,
        current_time: DateTime<Utc>,
    ) -> PredictionResult {
        // 1. 计算实际窗口大小
        let days_elapsed = (current_time - period_start).num_days() as usize;
        let actual_window = self.window_size.min(days_elapsed).max(1);
        
        // 2. 提取窗口内数据
        let window_start = current_time - chrono::Duration::days(actual_window as i64);
        let window_data: Vec<f64> = spending_history
            .iter()
            .filter(|(date, _)| *date >= window_start && *date <= current_time)
            .map(|(_, amount)| *amount)
            .collect();
        
        if window_data.is_empty() {
            return PredictionResult {
                predicted_total: 0.0,
                predicted_exceed: 0.0,
                confidence: 0.0,
                daily_average: 0.0,
                weighted_average: 0.0,
            };
        }
        
        // 3. 计算简单移动平均
        let daily_avg: f64 = window_data.iter().sum::<f64>() / window_data.len() as f64;
        
        // 4. 计算加权移动平均
        let weighted_avg = self.calculate_weighted_average(&window_data);
        
        // 5. 计算已支出金额
        let spent_so_far: f64 = spending_history
            .iter()
            .filter(|(date, _)| *date >= period_start && *date <= current_time)
            .map(|(_, amount)| *amount)
            .sum();
        
        // 6. 计算剩余天数和节假日因子
        let days_left = (period_end - current_time).num_days().max(0) as usize;
        let avg_holiday_factor = self.estimate_holiday_factor(current_time, period_end);
        
        // 7. 预测总支出
        let predicted_total = spent_so_far + weighted_avg * days_left as f64 * avg_holiday_factor;
        let predicted_exceed = (predicted_total - budget_amount).max(0.0);
        
        // 8. 计算置信度
        let confidence = self.calculate_confidence(&window_data, daily_avg);
        
        PredictionResult {
            predicted_total,
            predicted_exceed,
            confidence,
            daily_average: daily_avg,
            weighted_average: weighted_avg,
        }
    }
    
    /// 计算加权移动平均
    fn calculate_weighted_average(&self, data: &[f64]) -> f64 {
        let n = data.len();
        if n == 0 {
            return 0.0;
        }
        
        // 权重: 1, 2, 3, ..., n (线性递增)
        let weight_sum: f64 = (1..=n).sum::<usize>() as f64;
        let weighted_sum: f64 = data
            .iter()
            .enumerate()
            .map(|(i, &value)| value * (i + 1) as f64)
            .sum();
        
        weighted_sum / weight_sum
    }
    
    /// 估算未来期间的平均节假日因子
    fn estimate_holiday_factor(&self, start: DateTime<Utc>, end: DateTime<Utc>) -> f64 {
        let mut total_factor = 0.0;
        let mut days = 0;
        
        let mut current = start;
        while current <= end {
            let day_type = self.get_day_type(current);
            total_factor += self.holiday_factors.get(&day_type).unwrap_or(&1.0);
            days += 1;
            current += chrono::Duration::days(1);
        }
        
        if days > 0 {
            total_factor / days as f64
        } else {
            1.0
        }
    }
    
    /// 判断日期类型
    fn get_day_type(&self, date: DateTime<Utc>) -> String {
        // 简化实现，实际应查询节假日数据库
        match date.weekday() {
            chrono::Weekday::Sat | chrono::Weekday::Sun => "weekend".to_string(),
            _ => "workday".to_string(),
        }
    }
    
    /// 计算预测置信度
    fn calculate_confidence(&self, data: &[f64], mean: f64) -> f64 {
        if data.len() < 2 {
            return 0.5;
        }
        
        // 计算标准差
        let variance: f64 = data
            .iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / data.len() as f64;
        let std_dev = variance.sqrt();
        
        // 变异系数
        let cv = if mean > 0.0 {
            std_dev / mean
        } else {
            1.0
        };
        
        // 置信度: CV越小越可信
        1.0 / (1.0 + cv)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_budget_prediction() {
        let predictor = BudgetPredictor::new(30);
        
        // 模拟30天历史数据
        let start = Utc::now() - chrono::Duration::days(30);
        let spending_history: Vec<(DateTime<Utc>, f64)> = (0..30)
            .map(|i| {
                let date = start + chrono::Duration::days(i);
                let amount = 100.0 + (i as f64 * 2.0); // 递增趋势
                (date, amount)
            })
            .collect();
        
        let period_start = start;
        let period_end = start + chrono::Duration::days(60);
        let current_time = Utc::now();
        let budget_amount = 5000.0;
        
        let result = predictor.predict(
            &spending_history,
            budget_amount,
            period_start,
            period_end,
            current_time,
        );
        
        println!("预测总支出: {:.2}", result.predicted_total);
        println!("预测超支: {:.2}", result.predicted_exceed);
        println!("置信度: {:.2}", result.confidence);
        
        assert!(result.predicted_total > 0.0);
        assert!(result.confidence >= 0.0 && result.confidence <= 1.0);
    }
}
```

### 1.4 优化策略

#### 1.4.1 实时计算优化

```rust
/// 使用增量更新避免重复计算
pub struct IncrementalPredictor {
    predictor: BudgetPredictor,
    cache: HashMap<String, PredictionResult>,
    last_update: DateTime<Utc>,
}

impl IncrementalPredictor {
    /// 增量更新预测
    pub fn update(&mut self, new_transaction: f64, transaction_time: DateTime<Utc>) {
        // 只在新交易发生时重新计算
        let cache_key = format!("{}", transaction_time.date_naive());
        self.cache.remove(&cache_key);
        self.last_update = transaction_time;
    }
}
```

#### 1.4.2 并行计算

```rust
use rayon::prelude::*;

/// 批量预测多个预算
pub fn batch_predict(
    predictor: &BudgetPredictor,
    budgets: Vec<BudgetData>,
) -> Vec<PredictionResult> {
    budgets
        .par_iter()
        .map(|budget| {
            predictor.predict(
                &budget.spending_history,
                budget.amount,
                budget.start,
                budget.end,
                Utc::now(),
            )
        })
        .collect()
}
```

### 1.5 时间复杂度分析

- **数据提取**: O(n) - 遍历历史记录
- **加权平均**: O(W) - W为窗口大小(常数30)
- **节假日计算**: O(D) - D为剩余天数
- **总体**: O(n + W + D) ≈ O(n)

**空间复杂度**: O(W) - 存储窗口数据

## 2. 卡尔曼滤波汇率融合算法

### 2.1 算法概述

**目标**: 融合多个数据源的汇率数据，输出更准确稳定的汇率估值。

**应用场景**:
- Yahoo Finance (实时但有噪声)
- 央行官方汇率 (准确但延迟)
- 用户手动输入 (个性化但可能过时)

### 2.2 卡尔曼滤波原理

#### 2.2.1 状态空间模型

**状态方程**:
```
x_k = A * x_{k-1} + w_k
```
- x_k: 时刻k的真实汇率
- A: 状态转移矩阵 (汇率变化模型)
- w_k: 过程噪声 (均值0，协方差Q)

**观测方程**:
```
z_k = H * x_k + v_k
```
- z_k: 时刻k的观测值 (各数据源汇率)
- H: 观测矩阵
- v_k: 观测噪声 (均值0，协方差R)

#### 2.2.2 递推过程

**预测步骤**:
```
x̂_k⁻ = A * x̂_{k-1}
P_k⁻ = A * P_{k-1} * A^T + Q
```

**更新步骤**:
```
K_k = P_k⁻ * H^T * (H * P_k⁻ * H^T + R)^{-1}  # 卡尔曼增益
x̂_k = x̂_k⁻ + K_k * (z_k - H * x̂_k⁻)          # 状态更新
P_k = (I - K_k * H) * P_k⁻                      # 协方差更新
```

### 2.3 算法实现

```rust
use nalgebra::{Matrix1, Vector1};

/// 卡尔曼滤波器
pub struct KalmanFilter {
    /// 状态估计 (汇率估值)
    x: f64,
    /// 估计误差协方差
    p: f64,
    /// 过程噪声协方差
    q: f64,
    /// 观测噪声协方差
    r: f64,
}

/// 汇率数据源
#[derive(Debug, Clone)]
pub struct RateSource {
    pub name: String,
    pub rate: f64,
    pub weight: f64,      // 权重 (0-1)
    pub noise_variance: f64,  // 噪声方差
}

impl KalmanFilter {
    /// 创建新的卡尔曼滤波器
    pub fn new(initial_rate: f64, initial_variance: f64) -> Self {
        Self {
            x: initial_rate,
            p: initial_variance,
            q: 0.0001,  // 假设汇率变化较小
            r: 0.01,    // 默认观测噪声
        }
    }
    
    /// 预测步骤
    pub fn predict(&mut self) {
        // x̂_k⁻ = x̂_{k-1} (假设汇率不变)
        // self.x = self.x;
        
        // P_k⁻ = P_{k-1} + Q
        self.p += self.q;
    }
    
    /// 更新步骤
    pub fn update(&mut self, measurement: f64, measurement_noise: f64) {
        // 更新观测噪声
        self.r = measurement_noise;
        
        // 卡尔曼增益: K = P⁻ / (P⁻ + R)
        let kalman_gain = self.p / (self.p + self.r);
        
        // 状态更新: x̂ = x̂⁻ + K * (z - x̂⁻)
        self.x += kalman_gain * (measurement - self.x);
        
        // 协方差更新: P = (1 - K) * P⁻
        self.p *= 1.0 - kalman_gain;
    }
    
    /// 获取当前估计值
    pub fn get_estimate(&self) -> f64 {
        self.x
    }
    
    /// 获取估计误差
    pub fn get_variance(&self) -> f64 {
        self.p
    }
}

/// 多源汇率融合器
pub struct ExchangeRateFusion {
    filters: HashMap<String, KalmanFilter>,  // 每个货币对一个滤波器
}

impl ExchangeRateFusion {
    pub fn new() -> Self {
        Self {
            filters: HashMap::new(),
        }
    }
    
    /// 融合多个数据源的汇率
    pub fn fuse_rates(
        &mut self,
        currency_pair: &str,
        sources: &[RateSource],
    ) -> f64 {
        // 获取或创建滤波器
        let filter = self.filters.entry(currency_pair.to_string()).or_insert_with(|| {
            // 使用加权平均作为初始值
            let initial_rate = Self::weighted_average(sources);
            KalmanFilter::new(initial_rate, 0.01)
        });
        
        // 预测步骤
        filter.predict();
        
        // 对每个数据源进行更新
        for source in sources {
            filter.update(source.rate, source.noise_variance);
        }
        
        filter.get_estimate()
    }
    
    /// 计算加权平均
    fn weighted_average(sources: &[RateSource]) -> f64 {
        let total_weight: f64 = sources.iter().map(|s| s.weight).sum();
        if total_weight > 0.0 {
            sources.iter().map(|s| s.rate * s.weight).sum::<f64>() / total_weight
        } else {
            sources.first().map(|s| s.rate).unwrap_or(0.0)
        }
    }
    
    /// 获取融合后的汇率和置信度
    pub fn get_rate_with_confidence(
        &self,
        currency_pair: &str,
    ) -> Option<(f64, f64)> {
        self.filters.get(currency_pair).map(|filter| {
            let rate = filter.get_estimate();
            let variance = filter.get_variance();
            let confidence = 1.0 / (1.0 + variance);
            (rate, confidence)
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_kalman_filter() {
        let mut filter = KalmanFilter::new(6.5, 0.1);
        
        // 模拟多次观测
        let measurements = vec![6.52, 6.48, 6.51, 6.49, 6.50];
        
        for &z in &measurements {
            filter.predict();
            filter.update(z, 0.01);
            println!("估计值: {:.4}, 方差: {:.6}", filter.get_estimate(), filter.get_variance());
        }
        
        let final_estimate = filter.get_estimate();
        assert!(final_estimate > 6.45 && final_estimate < 6.55);
    }
    
    #[test]
    fn test_rate_fusion() {
        let mut fusion = ExchangeRateFusion::new();
        
        let sources = vec![
            RateSource {
                name: "央行".to_string(),
                rate: 6.50,
                weight: 0.5,
                noise_variance: 0.0001,  // 低噪声
            },
            RateSource {
                name: "Yahoo".to_string(),
                rate: 6.52,
                weight: 0.3,
                noise_variance: 0.01,    // 较高噪声
            },
            RateSource {
                name: "手动".to_string(),
                rate: 6.48,
                weight: 0.2,
                noise_variance: 0.05,    // 高噪声
            },
        ];
        
        let fused_rate = fusion.fuse_rates("CNY/USD", &sources);
        println!("融合后汇率: {:.4}", fused_rate);
        
        assert!(fused_rate > 6.45 && fused_rate < 6.55);
    }
}
```

### 2.4 实时更新策略

```rust
use tokio::time::{interval, Duration};

/// 后台汇率更新任务
pub async fn rate_update_task(fusion: Arc<Mutex<ExchangeRateFusion>>) {
    let mut interval = interval(Duration::from_secs(60)); // 每分钟更新
    
    loop {
        interval.tick().await;
        
        // 获取最新汇率数据
        let sources = fetch_exchange_rates().await;
        
        // 融合更新
        let mut fusion = fusion.lock().await;
        for (pair, sources) in sources {
            fusion.fuse_rates(&pair, &sources);
        }
    }
}

/// 从各数据源获取汇率
async fn fetch_exchange_rates() -> HashMap<String, Vec<RateSource>> {
    // 实现略: 并发请求多个API
    HashMap::new()
}
```

## 3. 智能去重算法

### 3.1 算法概述

**目标**: 批量导入交易时，自动识别并去除重复记录。

**去重维度**:
1. 精确匹配: 金额 + 日期 + 描述完全相同
2. 模糊匹配: 金额相同 + 日期相近(±3天) + 描述相似度>80%

### 3.2 算法实现

```rust
use std::collections::HashSet;
use sha2::{Sha256, Digest};

/// 交易去重器
pub struct TransactionDeduplicator {
    existing_hashes: HashSet<String>,
}

impl TransactionDeduplicator {
    pub fn new() -> Self {
        Self {
            existing_hashes: HashSet::new(),
        }
    }
    
    /// 加载已有交易的哈希
    pub fn load_existing_hashes(&mut self, transactions: &[Transaction]) {
        for tx in transactions {
            let hash = self.calculate_hash(tx);
            self.existing_hashes.insert(hash);
        }
    }
    
    /// 计算交易哈希
    fn calculate_hash(&self, tx: &Transaction) -> String {
        let mut hasher = Sha256::new();
        hasher.update(format!("{}", tx.amount));
        hasher.update(tx.transaction_date.to_rfc3339());
        hasher.update(&tx.description);
        format!("{:x}", hasher.finalize())
    }
    
    /// 检查是否重复
    pub fn is_duplicate(&self, tx: &Transaction) -> bool {
        let hash = self.calculate_hash(tx);
        self.existing_hashes.contains(&hash)
    }
    
    /// 去重并返回唯一交易
    pub fn deduplicate(&mut self, transactions: Vec<Transaction>) -> Vec<Transaction> {
        transactions
            .into_iter()
            .filter(|tx| {
                let hash = self.calculate_hash(tx);
                if self.existing_hashes.contains(&hash) {
                    false
                } else {
                    self.existing_hashes.insert(hash);
                    true
                }
            })
            .collect()
    }
}

/// 交易结构
#[derive(Debug, Clone)]
pub struct Transaction {
    pub amount: f64,
    pub transaction_date: DateTime<Utc>,
    pub description: String,
}
```

### 3.3 模糊匹配

```rust
/// 计算字符串相似度 (Levenshtein距离)
pub fn string_similarity(s1: &str, s2: &str) -> f64 {
    let len1 = s1.len();
    let len2 = s2.len();
    
    if len1 == 0 || len2 == 0 {
        return 0.0;
    }
    
    let distance = levenshtein_distance(s1, s2);
    let max_len = len1.max(len2);
    
    1.0 - (distance as f64 / max_len as f64)
}

fn levenshtein_distance(s1: &str, s2: &str) -> usize {
    let len1 = s1.len();
    let len2 = s2.len();
    let mut matrix = vec![vec![0; len2 + 1]; len1 + 1];
    
    for i in 0..=len1 {
        matrix[i][0] = i;
    }
    for j in 0..=len2 {
        matrix[0][j] = j;
    }
    
    for (i, c1) in s1.chars().enumerate() {
        for (j, c2) in s2.chars().enumerate() {
            let cost = if c1 == c2 { 0 } else { 1 };
            matrix[i + 1][j + 1] = (matrix[i][j + 1] + 1)
                .min(matrix[i + 1][j] + 1)
                .min(matrix[i][j] + cost);
        }
    }
    
    matrix[len1][len2]
}
```

## 4. 性能基准测试

### 4.1 预算预测性能

```rust
#[bench]
fn bench_budget_prediction(b: &mut Bencher) {
    let predictor = BudgetPredictor::new(30);
    let history = generate_test_data(365);
    
    b.iter(|| {
        predictor.predict(&history, 5000.0, start, end, now)
    });
}
```

**预期性能**: 单次预测 < 1ms

### 4.2 汇率融合性能

**预期性能**: 单次融合 < 0.5ms

### 4.3 去重性能

**预期性能**: 1000条记录去重 < 50ms
