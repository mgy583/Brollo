# 测试与部署方案

## 1. 测试策略

### 1.1 测试金字塔

```
           ┌─────────────┐
          /   E2E测试    /  (10%)
         /   UI测试      /
        /_______________ /
       /   集成测试      /    (20%)
      /   API测试       /
     /_________________/
    /   单元测试        /      (70%)
   /___________________/
```

### 1.2 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 工具 |
|---------|----------|------|
| 单元测试 | ≥80% | cargo test, rstest |
| 集成测试 | ≥60% | cargo test |
| API测试 | 100% | Postman, hurl |
| E2E测试 | 关键路径100% | Playwright |

## 2. 单元测试

### 2.1 Rust单元测试

```rust
// src/services/account_service.rs
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::predicate::*;
    use mockall::mock;
    
    mock! {
        AccountRepository {}
        
        impl AccountRepository {
            async fn find_by_id(&self, id: &str) -> Result<Account, Error>;
            async fn create(&self, account: Account) -> Result<Account, Error>;
        }
    }
    
    #[tokio::test]
    async fn test_create_account_success() {
        let mut mock_repo = MockAccountRepository::new();
        mock_repo
            .expect_create()
            .times(1)
            .returning(|account| Ok(account));
        
        let service = AccountService::new(mock_repo);
        let account = Account {
            id: "test_id".to_string(),
            name: "Test Account".to_string(),
            balance: 1000.0,
            ..Default::default()
        };
        
        let result = service.create_account(account).await;
        assert!(result.is_ok());
    }
    
    #[tokio::test]
    async fn test_get_account_not_found() {
        let mut mock_repo = MockAccountRepository::new();
        mock_repo
            .expect_find_by_id()
            .with(eq("invalid_id"))
            .times(1)
            .returning(|_| Err(Error::NotFound));
        
        let service = AccountService::new(mock_repo);
        let result = service.get_account("invalid_id").await;
        
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), Error::NotFound);
    }
}
```

### 2.2 参数化测试

```rust
use rstest::rstest;

#[rstest]
#[case(100.0, 50.0, 150.0)]
#[case(0.0, 100.0, 100.0)]
#[case(1000.0, -500.0, 500.0)]
fn test_balance_calculation(
    #[case] initial: f64,
    #[case] change: f64,
    #[case] expected: f64,
) {
    let result = calculate_new_balance(initial, change);
    assert_eq!(result, expected);
}
```

### 2.3 前端单元测试

```typescript
// src/components/__tests__/AccountCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { AccountCard } from '../AccountCard';

describe('AccountCard', () => {
  const mockAccount = {
    id: '1',
    name: 'Test Account',
    balance: 1000,
    currency: 'CNY',
  };
  
  it('renders account information correctly', () => {
    render(<AccountCard account={mockAccount} />);
    
    expect(screen.getByText('Test Account')).toBeInTheDocument();
    expect(screen.getByText('¥1,000.00')).toBeInTheDocument();
  });
  
  it('calls onEdit when edit button is clicked', () => {
    const onEdit = jest.fn();
    render(<AccountCard account={mockAccount} onEdit={onEdit} />);
    
    fireEvent.click(screen.getByRole('button', { name: /edit/i }));
    expect(onEdit).toHaveBeenCalledWith(mockAccount.id);
  });
});
```

## 3. 集成测试

### 3.1 API集成测试

```rust
// tests/integration_test.rs
use axum_test::TestServer;

#[tokio::test]
async fn test_account_crud_flow() {
    let app = create_test_app().await;
    let server = TestServer::new(app).unwrap();
    
    // 1. 创建账户
    let create_response = server
        .post("/api/v1/accounts")
        .json(&json!({
            "name": "Test Account",
            "type": "debit_card",
            "currency": "CNY",
            "initial_balance": 1000.0
        }))
        .await;
    
    assert_eq!(create_response.status(), 201);
    let account: Account = create_response.json();
    let account_id = account.id;
    
    // 2. 获取账户
    let get_response = server
        .get(&format!("/api/v1/accounts/{}", account_id))
        .await;
    
    assert_eq!(get_response.status(), 200);
    let retrieved_account: Account = get_response.json();
    assert_eq!(retrieved_account.name, "Test Account");
    
    // 3. 更新账户
    let update_response = server
        .patch(&format!("/api/v1/accounts/{}", account_id))
        .json(&json!({"name": "Updated Account"}))
        .await;
    
    assert_eq!(update_response.status(), 200);
    
    // 4. 删除账户
    let delete_response = server
        .delete(&format!("/api/v1/accounts/{}", account_id))
        .await;
    
    assert_eq!(delete_response.status(), 204);
}
```

### 3.2 数据库集成测试

```rust
use testcontainers::{clients, images::mongo::Mongo};

#[tokio::test]
async fn test_mongodb_operations() {
    let docker = clients::Cli::default();
    let mongo_image = Mongo::default();
    let node = docker.run(mongo_image);
    
    let host_port = node.get_host_port_ipv4(27017);
    let connection_string = format!("mongodb://localhost:{}", host_port);
    
    let client = mongodb::Client::with_uri_str(&connection_string)
        .await
        .unwrap();
    
    let db = client.database("test");
    let collection = db.collection::<Account>("accounts");
    
    // 测试插入
    let account = Account {
        name: "Test".to_string(),
        balance: 100.0,
        ..Default::default()
    };
    
    let result = collection.insert_one(account, None).await;
    assert!(result.is_ok());
    
    // 测试查询
    let count = collection.count_documents(None, None).await.unwrap();
    assert_eq!(count, 1);
}
```

## 4. E2E测试

### 4.1 Playwright E2E测试

```typescript
// e2e/account-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Account Management', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:3000');
    await page.fill('input[name="username"]', 'testuser');
    await page.fill('input[name="password"]', 'testpass');
    await page.click('button[type="submit"]');
    await page.waitForURL('**/dashboard');
  });
  
  test('should create new account', async ({ page }) => {
    // 导航到账户页面
    await page.click('a[href="/accounts"]');
    await expect(page).toHaveURL('**/accounts');
    
    // 点击创建按钮
    await page.click('button:has-text("创建账户")');
    
    // 填写表单
    await page.fill('input[name="name"]', 'Test Account');
    await page.selectOption('select[name="type"]', 'debit_card');
    await page.fill('input[name="initial_balance"]', '1000');
    
    // 提交
    await page.click('button[type="submit"]');
    
    // 验证创建成功
    await expect(page.locator('text=Test Account')).toBeVisible();
  });
  
  test('should update account balance after transaction', async ({ page }) => {
    // 前往交易页面
    await page.click('a[href="/transactions"]');
    
    // 创建交易
    await page.click('button:has-text("添加交易")');
    await page.selectOption('select[name="type"]', 'expense');
    await page.fill('input[name="amount"]', '50');
    await page.click('button[type="submit"]');
    
    // 返回账户页面验证余额
    await page.click('a[href="/accounts"]');
    await expect(page.locator('text=¥950.00')).toBeVisible();
  });
});
```

## 5. 性能测试

### 5.1 压力测试 (wrk)

```bash
# 基准测试脚本
# benchmark.sh

#!/bin/bash

# 测试配置
DURATION=60s
THREADS=4
CONNECTIONS=100
BASE_URL="http://localhost:8000"

echo "========================================="
echo "API性能压力测试"
echo "========================================="

# 1. 获取账户列表
echo -e "\n测试: GET /api/v1/accounts"
wrk -t${THREADS} -c${CONNECTIONS} -d${DURATION} \
    -H "Authorization: Bearer ${TOKEN}" \
    ${BASE_URL}/api/v1/accounts

# 2. 获取交易列表
echo -e "\n测试: GET /api/v1/transactions"
wrk -t${THREADS} -c${CONNECTIONS} -d${DURATION} \
    -H "Authorization: Bearer ${TOKEN}" \
    ${BASE_URL}/api/v1/transactions?page=1&page_size=20

# 3. 创建交易
echo -e "\n测试: POST /api/v1/transactions"
wrk -t${THREADS} -c${CONNECTIONS} -d${DURATION} \
    -s scripts/create_transaction.lua \
    ${BASE_URL}/api/v1/transactions
```

### 5.2 Lua脚本 (wrk)

```lua
-- scripts/create_transaction.lua
wrk.method = "POST"
wrk.headers["Content-Type"] = "application/json"
wrk.headers["Authorization"] = "Bearer " .. os.getenv("TOKEN")

request = function()
    local body = string.format([[{
        "type": "expense",
        "amount": %.2f,
        "currency": "CNY",
        "account_id": "507f1f77bcf86cd799439012",
        "category_id": "507f1f77bcf86cd799439020",
        "description": "Performance test transaction",
        "transaction_date": "%s"
    }]], math.random(1, 1000), os.date("!%Y-%m-%dT%H:%M:%SZ"))
    
    return wrk.format(nil, nil, nil, body)
end
```

### 5.3 性能基准目标

| 指标 | 目标值 | 测试条件 |
|-----|-------|---------|
| **QPS** | ≥10,000 req/s | GET /accounts (缓存命中) |
| **并发** | 50,000 连接 | 稳定响应 |
| **平均延迟** | <60ms | 5万并发 |
| **P95延迟** | <100ms | 5万并发 |
| **P99延迟** | <200ms | 5万并发 |
| **错误率** | <0.1% | 正常负载 |
| **CPU使用率** | <70% | 峰值负载 |
| **内存使用** | <2GB | 单实例 |

### 5.4 K6负载测试

```javascript
// loadtest.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

const errorRate = new Rate('errors');

export const options = {
  stages: [
    { duration: '2m', target: 100 },   // 爬坡到100用户
    { duration: '5m', target: 100 },   // 保持100用户
    { duration: '2m', target: 200 },   // 爬坡到200用户
    { duration: '5m', target: 200 },   // 保持200用户
    { duration: '2m', target: 0 },     // 降回0
  ],
  thresholds: {
    http_req_duration: ['p(95)<100'],  // 95%请求<100ms
    errors: ['rate<0.01'],             // 错误率<1%
  },
};

export default function () {
  const token = __ENV.TOKEN;
  const params = {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  };
  
  // 获取账户列表
  let res = http.get('http://localhost:8000/api/v1/accounts', params);
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 100ms': (r) => r.timings.duration < 100,
  }) || errorRate.add(1);
  
  sleep(1);
  
  // 创建交易
  const payload = JSON.stringify({
    type: 'expense',
    amount: Math.random() * 1000,
    currency: 'CNY',
    account_id: '507f1f77bcf86cd799439012',
    category_id: '507f1f77bcf86cd799439020',
    description: 'Load test transaction',
    transaction_date: new Date().toISOString(),
  });
  
  res = http.post('http://localhost:8000/api/v1/transactions', payload, params);
  check(res, {
    'status is 201': (r) => r.status === 201,
  }) || errorRate.add(1);
  
  sleep(1);
}
```

## 6. CI/CD流程

### 6.1 GitHub Actions工作流

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
      
      redis:
        image: redis:7.2
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
        components: rustfmt, clippy
    
    - name: Cache cargo registry
      uses: actions/cache@v3
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Cache cargo build
      uses: actions/cache@v3
      with:
        path: target
        key: ${{ runner.os }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}
    
    - name: Run cargo fmt
      run: cargo fmt -- --check
    
    - name: Run cargo clippy
      run: cargo clippy -- -D warnings
    
    - name: Run tests
      run: cargo test --verbose
      env:
        DATABASE_URL: mongodb://localhost:27017/test
        REDIS_URL: redis://localhost:6379
    
    - name: Generate coverage report
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --out Xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./cobertura.xml

  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: |
        docker build -t abook-backend:${{ github.sha }} .
    
    - name: Push to Docker Hub
      if: github.ref == 'refs/heads/main'
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker tag abook-backend:${{ github.sha }} abook/backend:latest
        docker push abook/backend:latest

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Deploy to production
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USER }}
        key: ${{ secrets.PROD_SSH_KEY }}
        script: |
          cd /opt/abook
          docker-compose pull
          docker-compose up -d
          docker-compose ps
```

### 6.2 前端CI/CD

```yaml
# .github/workflows/frontend.yml
name: Frontend CI/CD

on:
  push:
    branches: [ main ]
    paths:
      - 'frontend/**'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install dependencies
      working-directory: ./frontend
      run: npm ci
    
    - name: Run linter
      working-directory: ./frontend
      run: npm run lint
    
    - name: Run tests
      working-directory: ./frontend
      run: npm test -- --coverage
    
    - name: Build
      working-directory: ./frontend
      run: npm run build
    
    - name: Deploy to Vercel
      if: github.ref == 'refs/heads/main'
      uses: amondnet/vercel-action@v20
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        vercel-args: '--prod'
        working-directory: ./frontend
```

## 7. 部署方案

### 7.1 Docker部署

#### 7.1.1 后端Dockerfile

```dockerfile
# Dockerfile
# 多阶段构建

# 构建阶段
FROM rust:1.75 as builder

WORKDIR /app

# 复制依赖文件
COPY Cargo.toml Cargo.lock ./

# 构建依赖(缓存层)
RUN mkdir src && \
    echo "fn main() {}" > src/main.rs && \
    cargo build --release && \
    rm -rf src

# 复制源代码
COPY src ./src

# 构建应用
RUN cargo build --release

# 运行阶段
FROM debian:bookworm-slim

# 安装运行时依赖
RUN apt-get update && \
    apt-get install -y ca-certificates && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /app

# 从构建阶段复制二进制文件
COPY --from=builder /app/target/release/abook-backend ./

# 暴露端口
EXPOSE 8000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# 运行
CMD ["./abook-backend"]
```

#### 7.1.2 Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Nginx网关
  nginx:
    image: nginx:1.24
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - backend
    restart: unless-stopped
  
  # 后端服务
  backend:
    image: abook/backend:latest
    environment:
      - DATABASE_URL=mongodb://mongodb:27017/abook
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - RUST_LOG=info
    depends_on:
      - mongodb
      - redis
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '1'
          memory: 512M
    restart: unless-stopped
  
  # MongoDB
  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}
    restart: unless-stopped
  
  # Redis
  redis:
    image: redis:7.2
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    restart: unless-stopped
  
  # RabbitMQ
  rabbitmq:
    image: rabbitmq:3.12-management
    ports:
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    restart: unless-stopped
  
  # Prometheus监控
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    restart: unless-stopped
  
  # Grafana
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
    restart: unless-stopped

volumes:
  mongodb_data:
  redis_data:
  rabbitmq_data:
  prometheus_data:
  grafana_data:
```

### 7.2 Kubernetes部署

#### 7.2.1 部署配置

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: abook-backend
  namespace: abook-prod
spec:
  replicas: 3
  selector:
    matchLabels:
      app: abook-backend
  template:
    metadata:
      labels:
        app: abook-backend
    spec:
      containers:
      - name: backend
        image: abook/backend:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: abook-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: abook-secrets
              key: redis-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: abook-backend
  namespace: abook-prod
spec:
  selector:
    app: abook-backend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: abook-backend-hpa
  namespace: abook-prod
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: abook-backend
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

### 7.3 蓝绿部署

```bash
#!/bin/bash
# deploy.sh

VERSION=$1
NAMESPACE="abook-prod"

echo "部署版本: $VERSION"

# 1. 部署新版本(绿色环境)
kubectl apply -f k8s/deployment-green.yaml
kubectl set image deployment/abook-backend-green \
    backend=abook/backend:$VERSION \
    -n $NAMESPACE

# 2. 等待就绪
kubectl rollout status deployment/abook-backend-green -n $NAMESPACE

# 3. 切换流量
kubectl patch service abook-backend \
    -p '{"spec":{"selector":{"version":"green"}}}' \
    -n $NAMESPACE

# 4. 验证
sleep 10
if curl -f http://api.example.com/health; then
    echo "部署成功"
    # 删除旧版本
    kubectl delete deployment abook-backend-blue -n $NAMESPACE
else
    echo "部署失败，回滚"
    kubectl patch service abook-backend \
        -p '{"spec":{"selector":{"version":"blue"}}}' \
        -n $NAMESPACE
    exit 1
fi
```

## 8. 监控告警

### 8.1 Prometheus配置

```yaml
# prometheus/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'abook-backend'
    static_configs:
      - targets: ['backend:8000']
    metrics_path: /metrics

  - job_name: 'mongodb'
    static_configs:
      - targets: ['mongodb-exporter:9216']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
```

### 8.2 Grafana仪表盘

导入预配置的Grafana仪表盘监控关键指标。

## 9. 日志管理

### 9.1 ELK Stack

```yaml
# docker-compose.elk.yml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
  
  logstash:
    image: docker.elastic.co/logstash/logstash:8.11.0
    volumes:
      - ./logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf
    depends_on:
      - elasticsearch
  
  kibana:
    image: docker.elastic.co/kibana/kibana:8.11.0
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch

volumes:
  elasticsearch_data:
```

## 10. 灾难恢复

### 10.1 备份脚本

```bash
#!/bin/bash
# backup.sh

BACKUP_DIR="/backups"
DATE=$(date +%Y%m%d_%H%M%S)

# MongoDB备份
mongodump --uri="mongodb://admin:password@localhost:27017" \
    --out="${BACKUP_DIR}/mongodb_${DATE}"

# Redis备份
redis-cli --rdb "${BACKUP_DIR}/redis_${DATE}.rdb"

# 加密备份
tar -czf - "${BACKUP_DIR}/*_${DATE}" | \
    gpg --symmetric --cipher-algo AES256 > \
    "${BACKUP_DIR}/backup_${DATE}.tar.gz.gpg"

# 上传到云存储
aws s3 cp "${BACKUP_DIR}/backup_${DATE}.tar.gz.gpg" \
    s3://abook-backups/

# 清理旧备份(保留30天)
find ${BACKUP_DIR} -type f -mtime +30 -delete
```

### 10.2 恢复流程

```bash
#!/bin/bash
# restore.sh

BACKUP_FILE=$1

# 下载备份
aws s3 cp "s3://abook-backups/${BACKUP_FILE}" .

# 解密
gpg --decrypt "${BACKUP_FILE}" | tar -xzf -

# 恢复MongoDB
mongorestore --uri="mongodb://localhost:27017" ./mongodb_*/

# 恢复Redis
redis-cli --rdb ./redis_*.rdb
```
