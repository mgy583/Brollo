# 安全设计

## 1. 安全架构概览

```
┌────────────────────────────────────────────────────────┐
│                    安全防护层                           │
├────────────────────────────────────────────────────────┤
│  WAF  │  DDoS防护  │  CDN  │  SSL/TLS  │  限流     │
└───────┬────────────────────────────────────────────────┘
        │
┌───────▼────────────────────────────────────────────────┐
│                 应用安全层                              │
├────────────────────────────────────────────────────────┤
│  认证授权  │  输入验证  │  XSS防护  │  CSRF防护    │
└───────┬────────────────────────────────────────────────┘
        │
┌───────▼────────────────────────────────────────────────┐
│                 数据安全层                              │
├────────────────────────────────────────────────────────┤
│  加密存储  │  传输加密  │  数据脱敏  │  备份加密    │
└────────────────────────────────────────────────────────┘
```

## 2. 认证授权

### 2.1 JWT认证机制

#### 2.1.1 令牌结构

**Access Token** (有效期: 2小时)
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "507f1f77bcf86cd799439011",
    "username": "zhangsan",
    "role": "user",
    "iat": 1701504000,
    "exp": 1701511200
  },
  "signature": "..."
}
```

**Refresh Token** (有效期: 7天)
```json
{
  "payload": {
    "sub": "507f1f77bcf86cd799439011",
    "type": "refresh",
    "iat": 1701504000,
    "exp": 1702108800
  }
}
```

#### 2.1.2 实现代码

```rust
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use serde::{Deserialize, Serialize};
use chrono::{Utc, Duration};

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,      // 用户ID
    pub username: String,
    pub role: String,
    pub iat: i64,         // 签发时间
    pub exp: i64,         // 过期时间
}

pub struct JwtManager {
    secret: String,
    access_token_expiry: Duration,
    refresh_token_expiry: Duration,
}

impl JwtManager {
    pub fn new(secret: String) -> Self {
        Self {
            secret,
            access_token_expiry: Duration::hours(2),
            refresh_token_expiry: Duration::days(7),
        }
    }
    
    /// 生成访问令牌
    pub fn generate_access_token(
        &self,
        user_id: &str,
        username: &str,
        role: &str,
    ) -> Result<String, jsonwebtoken::errors::Error> {
        let now = Utc::now();
        let claims = Claims {
            sub: user_id.to_string(),
            username: username.to_string(),
            role: role.to_string(),
            iat: now.timestamp(),
            exp: (now + self.access_token_expiry).timestamp(),
        };
        
        encode(
            &Header::default(),
            &claims,
            &EncodingKey::from_secret(self.secret.as_bytes()),
        )
    }
    
    /// 验证令牌
    pub fn verify_token(&self, token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
        decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.secret.as_bytes()),
            &Validation::default(),
        )
        .map(|data| data.claims)
    }
    
    /// 刷新令牌
    pub fn refresh_access_token(
        &self,
        refresh_token: &str,
    ) -> Result<String, Box<dyn std::error::Error>> {
        // 1. 验证刷新令牌
        let claims = self.verify_token(refresh_token)?;
        
        // 2. 检查令牌类型
        // (简化版，实际应在claims中加type字段)
        
        // 3. 生成新的访问令牌
        self.generate_access_token(&claims.sub, &claims.username, &claims.role)
            .map_err(|e| e.into())
    }
}
```

### 2.2 令牌黑名单

```rust
use redis::Commands;

pub struct TokenBlacklist {
    redis: redis::Client,
}

impl TokenBlacklist {
    /// 将令牌加入黑名单
    pub async fn add_to_blacklist(&self, token: &str, expiry: i64) -> Result<(), redis::RedisError> {
        let mut conn = self.redis.get_connection()?;
        let key = format!("blacklist:token:{}", token);
        let ttl = (expiry - Utc::now().timestamp()) as usize;
        
        conn.set_ex(key, "1", ttl)?;
        Ok(())
    }
    
    /// 检查令牌是否在黑名单中
    pub async fn is_blacklisted(&self, token: &str) -> Result<bool, redis::RedisError> {
        let mut conn = self.redis.get_connection()?;
        let key = format!("blacklist:token:{}", token);
        
        conn.exists(key)
    }
}
```

### 2.3 RBAC权限模型

#### 2.3.1 角色定义

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Role {
    Admin,     // 管理员: 所有权限
    User,      // 普通用户: 基本权限
    Guest,     // 访客: 只读权限
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Permission {
    // 账户权限
    AccountRead,
    AccountCreate,
    AccountUpdate,
    AccountDelete,
    
    // 交易权限
    TransactionRead,
    TransactionCreate,
    TransactionUpdate,
    TransactionDelete,
    
    // 预算权限
    BudgetRead,
    BudgetCreate,
    BudgetUpdate,
    BudgetDelete,
    
    // 报表权限
    ReportRead,
    ReportExport,
    
    // 系统权限
    SystemManage,
}

impl Role {
    pub fn permissions(&self) -> Vec<Permission> {
        match self {
            Role::Admin => vec![
                Permission::AccountRead,
                Permission::AccountCreate,
                Permission::AccountUpdate,
                Permission::AccountDelete,
                Permission::TransactionRead,
                Permission::TransactionCreate,
                Permission::TransactionUpdate,
                Permission::TransactionDelete,
                Permission::BudgetRead,
                Permission::BudgetCreate,
                Permission::BudgetUpdate,
                Permission::BudgetDelete,
                Permission::ReportRead,
                Permission::ReportExport,
                Permission::SystemManage,
            ],
            Role::User => vec![
                Permission::AccountRead,
                Permission::AccountCreate,
                Permission::AccountUpdate,
                Permission::TransactionRead,
                Permission::TransactionCreate,
                Permission::TransactionUpdate,
                Permission::BudgetRead,
                Permission::BudgetCreate,
                Permission::ReportRead,
            ],
            Role::Guest => vec![
                Permission::AccountRead,
                Permission::TransactionRead,
                Permission::ReportRead,
            ],
        }
    }
}
```

#### 2.3.2 权限中间件

```rust
use axum::{
    extract::State,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};

pub async fn require_permission(
    State(required_permission): State<Permission>,
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    // 1. 从请求中提取用户信息
    let user = req.extensions().get::<User>()
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    // 2. 检查权限
    if !user.has_permission(&required_permission) {
        return Err(StatusCode::FORBIDDEN);
    }
    
    // 3. 继续处理请求
    Ok(next.run(req).await)
}

// 使用示例
app.route("/api/v1/accounts", post(create_account))
    .layer(axum::middleware::from_fn_with_state(
        Permission::AccountCreate,
        require_permission,
    ));
```

## 3. 密码安全

### 3.1 密码哈希 (Argon2id)

```rust
use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};

pub struct PasswordManager {
    argon2: Argon2<'static>,
}

impl PasswordManager {
    pub fn new() -> Self {
        Self {
            argon2: Argon2::default(),
        }
    }
    
    /// 哈希密码
    pub fn hash_password(&self, password: &str) -> Result<String, argon2::password_hash::Error> {
        let salt = SaltString::generate(&mut OsRng);
        let password_hash = self.argon2.hash_password(password.as_bytes(), &salt)?;
        Ok(password_hash.to_string())
    }
    
    /// 验证密码
    pub fn verify_password(
        &self,
        password: &str,
        hash: &str,
    ) -> Result<bool, argon2::password_hash::Error> {
        let parsed_hash = PasswordHash::new(hash)?;
        Ok(self.argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
    }
}
```

### 3.2 密码策略

```rust
use regex::Regex;

pub struct PasswordPolicy {
    min_length: usize,
    require_uppercase: bool,
    require_lowercase: bool,
    require_digit: bool,
    require_special: bool,
}

impl PasswordPolicy {
    pub fn default() -> Self {
        Self {
            min_length: 8,
            require_uppercase: true,
            require_lowercase: true,
            require_digit: true,
            require_special: true,
        }
    }
    
    pub fn validate(&self, password: &str) -> Result<(), String> {
        // 长度检查
        if password.len() < self.min_length {
            return Err(format!("密码长度至少{}位", self.min_length));
        }
        
        // 大写字母
        if self.require_uppercase && !password.chars().any(|c| c.is_uppercase()) {
            return Err("密码必须包含大写字母".to_string());
        }
        
        // 小写字母
        if self.require_lowercase && !password.chars().any(|c| c.is_lowercase()) {
            return Err("密码必须包含小写字母".to_string());
        }
        
        // 数字
        if self.require_digit && !password.chars().any(|c| c.is_numeric()) {
            return Err("密码必须包含数字".to_string());
        }
        
        // 特殊字符
        if self.require_special {
            let special_chars = Regex::new(r"[!@#$%^&*()_+\-=\[\]{};':\"\\|,.<>/?]").unwrap();
            if !special_chars.is_match(password) {
                return Err("密码必须包含特殊字符".to_string());
            }
        }
        
        Ok(())
    }
}
```

## 4. 数据加密

### 4.1 敏感数据加密 (AES-256-GCM)

```rust
use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};

pub struct DataEncryption {
    cipher: Aes256Gcm,
}

impl DataEncryption {
    pub fn new(key: &[u8; 32]) -> Self {
        Self {
            cipher: Aes256Gcm::new(key.into()),
        }
    }
    
    /// 加密数据
    pub fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>, aes_gcm::Error> {
        let nonce = Nonce::from_slice(b"unique nonce"); // 实际应随机生成
        self.cipher.encrypt(nonce, plaintext)
    }
    
    /// 解密数据
    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, aes_gcm::Error> {
        let nonce = Nonce::from_slice(b"unique nonce");
        self.cipher.decrypt(nonce, ciphertext)
    }
}

// 使用示例: 加密银行卡号
pub fn encrypt_card_number(card_number: &str, encryptor: &DataEncryption) -> String {
    let encrypted = encryptor.encrypt(card_number.as_bytes()).unwrap();
    base64::encode(encrypted)
}
```

### 4.2 数据脱敏

```rust
pub fn mask_card_number(card_number: &str) -> String {
    let len = card_number.len();
    if len <= 4 {
        return "*".repeat(len);
    }
    
    let last_four = &card_number[len - 4..];
    format!("{}****{}", "*".repeat(4), last_four)
}

pub fn mask_email(email: &str) -> String {
    if let Some(at_pos) = email.find('@') {
        let (local, domain) = email.split_at(at_pos);
        let masked_local = if local.len() <= 2 {
            "*".repeat(local.len())
        } else {
            format!("{}***", &local[..1])
        };
        format!("{}{}", masked_local, domain)
    } else {
        email.to_string()
    }
}

pub fn mask_phone(phone: &str) -> String {
    let len = phone.len();
    if len <= 7 {
        return "*".repeat(len);
    }
    
    format!("{}****{}", &phone[..3], &phone[len - 4..])
}
```

## 5. 输入验证与防护

### 5.1 输入验证

```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Validate, Deserialize)]
pub struct CreateAccountRequest {
    #[validate(length(min = 1, max = 100))]
    pub name: String,
    
    #[validate(custom = "validate_account_type")]
    pub account_type: String,
    
    #[validate(custom = "validate_currency")]
    pub currency: String,
    
    #[validate(range(min = 0.0))]
    pub initial_balance: f64,
}

fn validate_account_type(account_type: &str) -> Result<(), ValidationError> {
    let valid_types = vec!["cash", "debit_card", "credit_card", "investment", "loan"];
    if valid_types.contains(&account_type) {
        Ok(())
    } else {
        Err(ValidationError::new("invalid_account_type"))
    }
}

fn validate_currency(currency: &str) -> Result<(), ValidationError> {
    let valid_currencies = vec!["CNY", "USD", "EUR", "JPY", "GBP"];
    if valid_currencies.contains(&currency) {
        Ok(())
    } else {
        Err(ValidationError::new("invalid_currency"))
    }
}
```

### 5.2 XSS防护

```rust
use ammonia::clean;

/// 清理HTML输入
pub fn sanitize_html(input: &str) -> String {
    clean(input)
}

/// 转义特殊字符
pub fn escape_html(input: &str) -> String {
    input
        .replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}
```

### 5.3 SQL注入防护

```rust
// 使用参数化查询 (MongoDB示例)
use mongodb::bson::doc;

pub async fn find_transaction_safe(
    collection: &Collection<Transaction>,
    user_id: &str,
    amount: f64,
) -> Result<Vec<Transaction>, mongodb::error::Error> {
    // ✅ 安全: 使用参数化查询
    let filter = doc! {
        "user_id": user_id,
        "amount": amount,
    };
    
    let cursor = collection.find(filter, None).await?;
    // ...
    Ok(vec![])
}

// ❌ 不安全: 字符串拼接
// let query = format!("SELECT * FROM transactions WHERE user_id = '{}'", user_id);
```

### 5.4 CSRF防护

```rust
use axum::{
    extract::State,
    http::{header, HeaderMap, StatusCode},
    response::IntoResponse,
};

pub struct CsrfToken {
    token: String,
}

impl CsrfToken {
    pub fn generate() -> Self {
        Self {
            token: uuid::Uuid::new_v4().to_string(),
        }
    }
    
    pub fn verify(&self, token: &str) -> bool {
        self.token == token
    }
}

// CSRF中间件
pub async fn csrf_protection(
    headers: HeaderMap,
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    // GET、HEAD、OPTIONS请求不需要CSRF保护
    if matches!(req.method(), &Method::GET | &Method::HEAD | &Method::OPTIONS) {
        return Ok(next.run(req).await);
    }
    
    // 验证CSRF令牌
    let csrf_token = headers
        .get("X-CSRF-Token")
        .and_then(|v| v.to_str().ok())
        .ok_or(StatusCode::FORBIDDEN)?;
    
    // 从session中获取存储的令牌并验证
    // (简化实现)
    
    Ok(next.run(req).await)
}
```

## 6. 通信安全

### 6.1 HTTPS/TLS配置

```nginx
# Nginx SSL配置
server {
    listen 443 ssl http2;
    server_name api.example.com;
    
    # SSL证书
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    
    # SSL协议
    ssl_protocols TLSv1.2 TLSv1.3;
    
    # 加密套件
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers on;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # 其他安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    
    location / {
        proxy_pass http://backend;
    }
}

# HTTP重定向到HTTPS
server {
    listen 80;
    server_name api.example.com;
    return 301 https://$server_name$request_uri;
}
```

### 6.2 API签名验证

```rust
use hmac::{Hmac, Mac};
use sha2::Sha256;

type HmacSha256 = Hmac<Sha256>;

pub fn generate_signature(data: &str, secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(secret.as_bytes())
        .expect("HMAC can take key of any size");
    mac.update(data.as_bytes());
    let result = mac.finalize();
    hex::encode(result.into_bytes())
}

pub fn verify_signature(data: &str, signature: &str, secret: &str) -> bool {
    let expected = generate_signature(data, secret);
    expected == signature
}
```

## 7. 日志与审计

### 7.1 安全日志

```rust
use tracing::{info, warn, error};

pub fn log_login_attempt(username: &str, success: bool, ip: &str) {
    if success {
        info!(
            username = username,
            ip = ip,
            "User login successful"
        );
    } else {
        warn!(
            username = username,
            ip = ip,
            "User login failed"
        );
    }
}

pub fn log_permission_denied(user_id: &str, resource: &str, action: &str) {
    warn!(
        user_id = user_id,
        resource = resource,
        action = action,
        "Permission denied"
    );
}

pub fn log_data_access(user_id: &str, resource_type: &str, resource_id: &str) {
    info!(
        user_id = user_id,
        resource_type = resource_type,
        resource_id = resource_id,
        "Data access"
    );
}
```

### 7.2 审计日志

```rust
#[derive(Debug, Serialize)]
pub struct AuditLog {
    pub timestamp: DateTime<Utc>,
    pub user_id: String,
    pub action: String,
    pub resource_type: String,
    pub resource_id: String,
    pub ip_address: String,
    pub user_agent: String,
    pub status: String,
    pub details: serde_json::Value,
}

pub async fn create_audit_log(
    db: &Database,
    log: AuditLog,
) -> Result<(), mongodb::error::Error> {
    let collection = db.collection::<AuditLog>("audit_logs");
    collection.insert_one(log, None).await?;
    Ok(())
}
```

## 8. 速率限制

### 8.1 令牌桶算法

```rust
use std::time::{Duration, Instant};

pub struct TokenBucket {
    capacity: usize,
    tokens: usize,
    refill_rate: usize,
    last_refill: Instant,
}

impl TokenBucket {
    pub fn new(capacity: usize, refill_rate: usize) -> Self {
        Self {
            capacity,
            tokens: capacity,
            refill_rate,
            last_refill: Instant::now(),
        }
    }
    
    pub fn try_consume(&mut self, tokens: usize) -> bool {
        self.refill();
        
        if self.tokens >= tokens {
            self.tokens -= tokens;
            true
        } else {
            false
        }
    }
    
    fn refill(&mut self) {
        let now = Instant::now();
        let elapsed = now.duration_since(self.last_refill);
        let new_tokens = (elapsed.as_secs() as usize) * self.refill_rate;
        
        if new_tokens > 0 {
            self.tokens = (self.tokens + new_tokens).min(self.capacity);
            self.last_refill = now;
        }
    }
}
```

### 8.2 Redis限流

```rust
use redis::Commands;

pub async fn check_rate_limit(
    redis: &redis::Client,
    key: &str,
    limit: usize,
    window: usize,
) -> Result<bool, redis::RedisError> {
    let mut conn = redis.get_connection()?;
    
    let count: usize = conn.incr(key, 1)?;
    
    if count == 1 {
        conn.expire(key, window)?;
    }
    
    Ok(count <= limit)
}
```

## 9. 安全检查清单

### 9.1 代码安全

- [ ] 所有输入经过验证
- [ ] 密码使用Argon2id哈希
- [ ] 敏感数据加密存储
- [ ] 使用参数化查询
- [ ] 防止XSS攻击
- [ ] 防止CSRF攻击
- [ ] 防止SQL注入

### 9.2 认证授权

- [ ] 实现JWT认证
- [ ] 令牌定期轮换
- [ ] 实施RBAC权限控制
- [ ] 会话超时管理
- [ ] 多因素认证(可选)

### 9.3 网络安全

- [ ] 启用HTTPS
- [ ] 配置安全响应头
- [ ] 实施速率限制
- [ ] 部署WAF
- [ ] DDoS防护

### 9.4 数据安全

- [ ] 数据库访问控制
- [ ] 数据定期备份
- [ ] 备份加密存储
- [ ] 数据脱敏展示
- [ ] 日志安全存储

### 9.5 运维安全

- [ ] 定期安全审计
- [ ] 漏洞扫描
- [ ] 依赖项安全检查
- [ ] 异常监控告警
- [ ] 应急响应预案

## 10. 安全测试

### 10.1 渗透测试

```bash
# 使用OWASP ZAP进行漏洞扫描
docker run -v $(pwd):/zap/wrk/:rw -t owasp/zap2docker-stable zap-baseline.py \
    -t https://api.example.com \
    -r security_report.html
```

### 10.2 依赖安全检查

```bash
# Rust依赖安全审计
cargo audit

# 前端依赖安全检查
npm audit
```
